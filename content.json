{"posts":[{"title":"Spring简介&amp;IOC简介","text":"学习视频🎥：https://www.bilibili.com/video/BV1Vf4y127N5 一、Spring简介💬概述：Spring 是轻量级的开源的JavaEE框架，IOC和AOP是Spring 的两个核心部分 轻量级：Spring 需要配置的依赖（jar 包）较少，也不需要额外添加其他依赖，整体体积也较小，可以独立使用 🎯目的：简化企业应用开发 🔑特点： 方便解耦，简化开发 支持AOP编程（不修改源码就能实现功能扩展） 方便程序测试和事务管理操作 方便与其他框架进行整合，如整合 MyBatis 简化 JavaAPI 的使用 二、IOC2.1 简介💬概述：Inversion Of Control 控制反转，意思就是将对象的创建权反转（交给）了Spring，或者说对象创建的控制权不是”使用者”，而是”框架”或者”容器” 🎯作用与目的： 简化操作：将对象的创建和对象之间的调用交给Spring处理 降低耦合度：对象之间的调用操作采用工厂模式间接实现，从而降低两个对象之间调用的耦合度 2.2 底层原理🔑底层实现技术：xml 解析、工厂模式、反射 🔑IOC 实现过程：IOC思想基于IOC容器完成，IOC容器底层就是对象工厂 创建对象（以xml 配置为例）：在xml 配置文件中配置将要创建的对象1&lt;bean id=&quot;uDao&quot; class=&quot;com.Key.dao.UserDao&quot;&gt;&lt;/bean&gt; 创建工厂类：在工厂类中解析xml 文件和通过反射创建对象1234567891011public class UserFactory { public static UserDao getUserDao() { // 1. 解析xml文件，获取对应的class属性值，此处简略具体代码... String classValue = class属性值...; // 2. 通过反射创建对象 UserDao uDao = (UserDao)Class.forName(classValue).newInstance(); return uDao; }} 🔑IOC 底层中的工厂模式 2.3 获取对象的API🔑 接口 ① BeanFactory IOC容器的基本实现，是Spring内部使用的接口，开发人员一般不使用 特点：加载配置文件时不会创建对象，在获取对象时才创建 ② ApplicationContext（推荐） BeanFactory接口的子接口，提供更强大的功能，一般由开发人员使用 特点：在加载配置文件的时候就已经创建好对象 ❓为什么使用ApplicationContext会更好：配置文件、创建对象等操作比较耗时耗资源，所以一般将这些操作放在项目启动（服务器启动）前完成，项目启动后就可以直接使用，而不是等到要使用时才来创建📚常见八股文：BeanFactory和ApplicationContext的区别 🔑对应实现类 FileSystemXmlApplicationContext：传入参数为文件的全路径，即在磁盘中的位置 ClassPathXmlApplicationContext：传入参数为文件在项目中src的类路径，如果放在src目录下，直接写文件名即可123456// 加载spring配置文件（xml），创建工厂类对象// 1. 方式一BeanFactory context01 = new ClassPathXmlApplicationContext(&quot;bean01.xml&quot;);// 2. 方式二ApplicationContext context02 = new ClassPathXmlApllicationContext(&quot;bean01.xml&quot;); 🔑获取对象 123456/* 根据创建的工厂类对象context，获取对应对象 - 第一个参数：xml文件中&lt;bean&gt;标签的id属性值 - 第二个参数：需要获取的对象对应的Class对象（如果不写，返回对象类型默认是Object）*/UserDao userDao = context.getBean(&quot;uDao&quot;, UserDao.class);","link":"/posts/20221206fe655437768f"},{"title":"Bean管理-基于注解","text":"学习视频🎥：https://www.bilibili.com/video/BV1Vf4y127N5 * 开启注解 ❓ 注解：代码特殊标记 格式为：@注解名称(属性名=属性值,属性名={属性值1,属性值2})。各个属性之间用,隔开，同一个属性的多个属性值用{}括起来，并用,隔开 使用方式：可以作用在类、方法、成员变量上 作用：简化xml 配置 🔑导入jar 包：spring-aop-…-RELEASE.jar 🔑开启组件扫描：有两种方式 ① 在xml 文件中配置 指定包扫描：在xml 文件中添加context 名称空间，然后使用&lt;context:component-scan&gt;标签 1&lt;context:component-scan base-package=&quot;com.Key&quot;&gt;&lt;/context:component-scan&gt; ❓ &lt;context:component-scan&gt;标签中的base-package属性：需要扫描的包的全路径，有两种写法。如果需要扫描的包在不同包下，则可以添加多个包的全路径，不同包通过,隔开；如果需要扫描的包在同一个包下，则直接写需要扫描的包的上一层包即可（包），如dao包和service包都在com.Key下，则直接写”com.Key”即可 1234&lt;!-- 写法1 --&gt;&lt;context:component-scan base-package=&quot;com.Key.dao,com.Key.service&quot;&gt;&lt;/context:component-scan&gt;&lt;!-- 写法2 --&gt; &lt;context:component-scan base-package=&quot;com.Key&quot;&gt;&lt;/context:component-scan&gt; 指定注解进行扫描12345&lt;!-- 设置只扫描含有@Controller注解 --&gt;&lt;context:component-scan base-package=&quot;com.Key&quot; use-default-filter=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;...Controller&quot;&gt;&lt;/context:include-filter&gt;&lt;/context:component-scan&gt; 排除某种注解进行扫描 12345&lt;!-- 设置除了@Controller注解不扫描，其他注解都扫描 --&gt;&lt;context:component-scan base-package=&quot;com.Key&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;...Controller&quot;&gt;&lt;/context:exclude-filter&gt;&lt;/context:component-scan&gt; ❓ 各个标签及其属性说明 use-default-filters属性：表示是否使用默认的filters（过滤器）。默认值为”true”，表示使用默认过滤器，则对于指定包中所有注解都进行扫描；如果值为”false”，表示不使用默认过滤器，只扫描指定的注解 &lt;context:include-filter&gt;标签：设置包含过滤器——设置指定注解（include）的过滤器 &lt;context:exclude-filter&gt;标签：设置非包含过滤器——设置排除某个注解（exclude）的过滤器 type属性：值为”annotation”，表示扫描的是注解 expression属性：指定注解名的位置，如org.springframework.stereotype.Controller ② 创建配置类 使用：创建一个类，在类的上面添加@Configuration和@ComponentScan注解，并在@ComponentScan注解中添加basePackages属性（对应xml 配置中的base-package属性），属性值的写法与base-package属性一样 💡 basePackages属性是数组，可以添加多个属性值，如果只有单个属性值时可以直接写一个值，也可以将属性值写在{}中 12345@Configuration@ComponentScan(basePackages = {&quot;com.Key&quot;})public class SpringConfig { // code...} 作用：脱离xml文件配置，实现完全注解开发 获取工厂对象：实现完全注解开发说明不能通过加载xml 配置文件获取工厂对象，而是需要加载配置类的字节码文件（.class）来获取 12345// 1. 通过加载xml 配置文件获取工厂对象ApplicationContext context01 = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);// 2. 通过加载配置类(SpringConfig)字节码文件获取工厂对象ApplicationContext context02 = new AnnotationConfigApplicationContext(SpringConfig.class); * 创建对象🔑4个注解：创建对象有4种方式，4种注解方式都是一样的，只是用于标识项目开发中不同层的类 @Component：适用于普通组件和普通类 @Service：适用于业务逻辑层（Service层） @Controller：适用于Web层、控制器（Controller层） @Repository：适用于持久层（Dao层） 🔑给对象添加唯一标识：基于以上注解，添加value属性（不是id） value属性对应xml 配置中&lt;bean&gt;标签的id属性 可以省略value属性，默认值为第一个字母小写的类名123456@Service(value = &quot;userService&quot;)public class UserService { public void add() { System.out.println(&quot;基于注解方式创建对象...&quot;); }} * 注入属性 💡 使用注解方式注入属性时，内部已经封装好set 方法，不需要在类中添加 🔑注入普通类型属性 在成员变量上添加@Value注解，注解中添加value属性，属性值就是成员变量的值 12@Value(value = &quot;刘备&quot;)private String name; 🔑注入对象类型属性 💡 下面的测试代码是基于dao层和service层的关系——在UserService类中添加UserDao类型的成员变量，其中UserDao是接口类，UserDaoImpl是对应的实现类💡 @Autowire和@Qualifier是spring中特有的注解，而@Resource是Java中自带的注解（在java拓展包javax中），所以spring官方推荐使用前两种 ① @Autowired：根据成员变量对应的对象类型自动装配，可以单独使用 💡 根据变量对应的对象类型自动装配前提是该对象类型接口只有一个实现类 12@Autowiredprivate UserDao userDao; ② @Qualifier：根据成员变量对应的对象唯一标识（对象名）注入属性，与@Autowire一起使用，需要添加value属性，属性值为变量对应的对象唯一标识 💡 当变量对应的对象类型接口（UserDao）有多个实现类（UserDaoImpl）时，需要添加@Qualifier注解，并标注对象名，找到指定的实现类对象，不能直接使用@Autowire注解 123@Autowired@Qualifier(value = &quot;userDaoImpl01&quot;)private UserDao userDao; ③ @Resource：可以根据类型注入，也可以名称注入，可以单独使用。 根据类型：直接在成员变量前加上@Resource 12@Resourceprivate UserDao userDao; 根据名称：需要添加name属性（不是value），属性值为变量对应的对象唯一标识（跟@Qualifier中的value一样） 12@Resource(name = &quot;userDaoImpl02&quot;)private UserDao userDao;","link":"/posts/20221208f10f9b281c34"},{"title":"Bean管理-基于xml","text":"学习视频🎥：https://www.bilibili.com/video/BV1Vf4y127N5 一、Bean管理简介💬概述：Bean管理就是对象管理，指的就是两个操作 Spring 创建对象：创建对象默认采用的是无参构造器，所以类的定义中必须有无参构造器的声明或者不添加有参构造器 Spring 注入属性：也就是 DI——Dependency Injection 依赖注入 📚常见八股文：DI与IOC的区别 🔑Bean管理操作的两种方式 基于xml 文件实现 基于注解方式实现（推荐） 二、使用xml管理Bean2.1 创建对象在spring配置文件（spring.xml）使用&lt;bean&gt;标签并添加对应属性 1&lt;bean id=&quot;u&quot; class=&quot;com.Key.spring.bean.User&quot;&gt;&lt;/bean&gt; &lt;bean&gt;标签中两个重要属性 id：对象的唯一标识 class：对象的全类名 2.2 注入属性 💡 2.2.2~2.2.5只使用了set方法进行注入 2.2.1 普通类型属性🔑使用set() 方法进行注入 定义一个类，添加setProperty() 方法1234567891011121314151617/** * User实体类 * - 成员变量一：name * - 成员变量二：age */public class User { private String name; private int age; public void setName(String name) { this.name = name; } public void setAge(int age) { this.age = age; }} 在xml 文件中的&lt;bean&gt;标签中添加&lt;property&gt;标签，并添加相应属性1234&lt;bean id=&quot;u&quot; class=&quot;com.Key.spring.bean.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;周瑜&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;24&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;property&gt;标签中的两个属性 name：属性名。注意这里是对应的是属性名，即与方法setXxx() 中的xxx对应，不一定是成员变量名 value：对应属性值（成员变量的值） 🔑p名称空间注入：set() 方法注入的简化操作（了解即可） 在配置文件中的&lt;beans&gt;标签中创建p名称空间：xmlns:p=&quot;http://www.springframework.org/schema/p&quot;1234567&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- code... --&gt;&lt;/beans&gt; 直接在&lt;baen&gt;标签的属性栏上添加属性 p:property 进行属性的注入 注入外部Bean的写法：p:uDao-ref=&quot;uDao&quot; 1&lt;bean id=&quot;u&quot; class=&quot;com.Key.spring.bean.User&quot; p:name=&quot;周瑜&quot; p:age=&quot;24&quot;&gt;&lt;/bean&gt; 🔑使用有参构造器进行注入 定义一个类，添加有参构造器123456789public class User { private String name; private int age; public User(String username, int age) { this.name = username; this.age = age; }} 在xml 文件中的&lt;bean&gt;标签中添加&lt;constructor-arg&gt;标签，并添加对应属性1234&lt;bean id=&quot;u&quot; class=&quot;com.key.spring.bean.User&quot;&gt; &lt;constructor-arg name=&quot;username&quot; value=&quot;诸葛亮&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; &lt;constructor-arg&gt;标签的重要属性 name：有参构造器中形参的名称。注意这里对应的是形参名，不一定是属性名，也不一定是成员变量名 value：对应属性值（成员变量值） index：成员变量在类中定义的先后次序，从0开始 2.2.2 特殊类型属性 引入概念——字面量：Java 中将数据称为字面量，如在int a = 2;中，a是变量，2就是字面量 🔑注入null值：直接在&lt;property&gt;标签体中添加&lt;null/&gt;标签即可 123&lt;property name=&quot;name&quot;&gt; &lt;null/&gt;&lt;/property&gt; 🔑注入带特殊符号的属性值：特殊符号是指在xml 中有特殊用法的敏感字符，如&lt;、&gt;、&amp;等 使用转义字符代替特殊符号 使用&lt;value&gt;标签和CDATA区域，把带有特殊符号值放在CDATA区域，如把”&lt;&lt;三国演义&gt;&gt;”赋值给属性bookName123&lt;property name=&quot;bookName&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;三国演义&gt;&gt;]]&gt;&lt;/value&gt;&lt;/property&gt; 🔑注入数组、集合类型属性（List 和数组注入方式一样，这里只演示数组） 数组或集合元素类型为普通类型 ① 创建一个类用于测试，类中定义有数组类型、set类型和Map类型的属性 1234567891011121314151617public class Students { private String[] course; private Map&lt;String,String&gt; stuMap; private Set&lt;String&gt; stuSet; public void setCourse(String[] course) { this.course = course; } public void setStuMap(Map&lt;String, String&gt; stuMap) { this.stuMap = stuMap; } public void setStuSet(Set&lt;String&gt; stuSet) { this.stuSet = stuSet; }} ② 在spring配置文件中创建对象，并注入各个类型的属性（都是在&lt;property&gt;标签中添加） 数组或List 集合类型注入：添加&lt;array&gt;或&lt;list&gt;标签，然后在&lt;array&gt;或&lt;list&gt;标签体中添加&lt;value&gt;进行赋值1234&lt;list&gt; &lt;value&gt;高数&lt;/value&gt; &lt;value&gt;c语言&lt;/value&gt;&lt;/list&gt; set 集合类型注入：添加&lt;set&gt;标签，然后在&lt;set&gt;标签体中添加&lt;value&gt;进行赋值1234&lt;set&gt; &lt;value&gt;set1&lt;/value&gt; &lt;value&gt;set2&lt;/value&gt;&lt;/set&gt; map 集合类型注入：添加&lt;map&gt;标签，然后在&lt;map&gt;标签体中添加&lt;entry&gt;标签，在&lt;entry&gt;标签的属性中进行赋值1234&lt;map&gt; &lt;entry key=&quot;周一&quot; value=&quot;上课&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;周日&quot; value=&quot;放假&quot;&gt;&lt;/entry&gt;&lt;/map&gt; &lt;entry&gt;标签的两个属性 key：对应map 集合中的键key value：对应map 集合中的值value 数组或集合元素类型为对象（数组、集合类型的操作都是相似的，这里只演示List 集合） ① 创建课程类，在学生类中添加元素类型是课程类的集合属性——private List&lt;Course&gt; stuCourse; 1234567public class Course { private String cname; public void setCname(String cname) { this.cname = cname; }} ② 在spring 配置文件中创建多个课程类对象，然后再学生对象的创建中注入对应集合属性，集合中添加创建好的多个课程对象，将&lt;value&gt;标签换成&lt;ref&gt;，并通过bean 属性赋值 123456789101112131415161718192021222324&lt;!-- 创建多个课程类对象 --&gt;&lt;bean id=&quot;c1&quot; class=&quot;com.Key.spring.ioc.bean.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;java实验课&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;c2&quot; class=&quot;com.Key.spring.ioc.bean.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;c语言实验课&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;c3&quot; class=&quot;com.Key.spring.ioc.bean.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;数据结构实验课&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 创建学生对象，并对其多个数组、集合类型属性赋值 --&gt;&lt;bean id=&quot;stu&quot; class=&quot;com.Key.spring.ioc.bean.Students&quot;&gt; &lt;!-- 这里省略其他属性的注入... --&gt; &lt;!-- 给list集合赋值，list集合元素类型是Course --&gt; &lt;property name=&quot;stuCourse&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;c1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;c2&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;c3&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; &lt;ref&gt;标签的属性——bean：集合中每个元素对象对应的唯一标识id 值 通过util 名称空间实现数组或集合类型的注入（将集合类型属性的注入单独取出来） ① 在spring 配置文件的根标签&lt;beans&gt;的属性栏中创建util 名称空间 添加属性——xmlns:util=&quot;http://www.springframework.org/schema/util&quot; 在xsi:schemaLocation属性的原有值后添加http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd 创建util 名称空间的方法（通用） 将属性xmlns的值http://www.springframework.org/schema/beans中的beans换成util 将属性xsi:schemaLocation的原有值http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd中的所有beans都换成util 12345678&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;!-- code... --&gt;&lt;/beans&gt; ② 在创建对象的外部使用&lt;util:list&gt; 标签对集合类型属性进行赋值（其他集合类型的赋值类似——&lt;util:map&gt;、&lt;util:set&gt;） 12345&lt;!-- 使用util名称空间在创建对象外部对集合类型属性赋值 --&gt;&lt;util:list id=&quot;utilList&quot;&gt; &lt;value&gt;大物&lt;/value&gt; &lt;value&gt;离散&lt;/value&gt;&lt;/util:list&gt; ③ 把已经注入完成的集合类型属性添加到对象中：在&lt;property&gt;标签中采用 ref 属性，与注入对象类属性的方式类似 123456&lt;!-- 创建学生对象，并注入属性 --&gt;&lt;bean id=&quot;stu&quot; class=&quot;com.Key.spring.ioc.bean.Students&quot;&gt; &lt;!-- 这里省略其他属性的注入... --&gt; &lt;property name=&quot;course&quot; ref=&quot;utilList&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2.2.3 对象类型属性🔑用法：用于有调用关系的类之间，比如service类和dao类 ① 创建好service类和dao类，在service类中定义dao类的成员变量，根据成员变量调用其方法 123456789101112131415161718/** * 注意：这里只是简单演示，实操的时候需要添加接口类，在实现类进行以下操作 */public class UserService { private UserDao uDao; // 要加上对应的set方法 public void setUDao(UserDao uDao) { this.uDao = uDao; } public void update() { // 调用dao类对象的方法 uDao.update(); // code... }} ② 在spring配置文件中创建service类对象和dao类对象，并在service类对象中注入属性，有外部和内部两种方式 外部Bean方式注入：在外部创建好属性对应的类对象，然后根据外部Bean的唯一标识id 进行注入 12345678910&lt;!-- 在外部创建dao类对象 - 注意：这里这是简单演示，实操的时候，class中写的应该是实现类的全类名，而不是接口，下同--&gt;&lt;bean id=&quot;uDao&quot; class=&quot;com.Key.spring.dao.UserDao&quot;&gt;&lt;/bean&gt;&lt;!-- 创建service类对象，并注入属性 --&gt;&lt;bean id=&quot;uService&quot; class=&quot;com.Key.spring.service.UserService&quot;&gt; &lt;property name=&quot;uDao&quot; ref=&quot;uDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;property&gt;标签中的两个属性 name：属性名 ref：对象类型属性在外部创建时&lt;bean&gt;标签中的id值（唯一标识） 内部Bean的方式注入：直接在&lt;property&gt;标签体（内部）中使用&lt;bean&gt;标签创建属性对应的类对象12345678910&lt;!-- 创建service类对象，并注入属性 - 在&lt;property&gt;标签体（内部）中创建属性对应的类对象 - 内部的&lt;bean&gt;标签可以不添加id属性--&gt;&lt;bean id=&quot;uService&quot; class=&quot;com.Key.spring.service.UserService&quot;&gt; &lt;property name=&quot;uDao&quot;&gt; &lt;bean id=&quot;uDao&quot; class=&quot;com.Key.spring.dao.UserDao&quot;&gt;&lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 2.2.4 级联赋值① 创建部门类和员工类，在员工类中添加部门类型的成员变量，表示两者一对多的关系 ② 在spring 配置文件中创建两个类的对象，并对员工属性的注入中同时对其所在的部门的属性进行赋值，实现级联赋值 通过外部Bean或内部Bean的方式（这里只演示外部）1234567891011121314151617&lt;!-- 在外部创建部门对象 - 部门对象有属性deptName，这里直接赋值--&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.Key.spring.bean.Department&quot;&gt; &lt;property name=&quot;deptName&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 创建员工对象，并注入属性 - 外部部门对象的属性已经赋值，这里直接通过ref属性注入部门对象即可 --&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.Key.spring.bean.Employee&quot;&gt; &lt;property name=&quot;empName&quot; value=&quot;孙尚香&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;empDept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 通过对象.属性（这里对象是指员工中的部门属性）的方式（这里是基于外部Bean的方式，内部Bean的方式也可以） 先在员工类中添加部门属性对应的get方法，不然无法找到对象.属性中的对象 在员工对象创建的&lt;bean&gt;标签体中添加&lt;property name=&quot;empDept.deptName&quot; value=&quot;销售部&quot;&gt;&lt;/property&gt; 123456789101112131415&lt;!-- 在外部创建部门对象 --&gt;&lt;bean id=&quot;dept&quot; class=&quot;com.Key.spring.bean.Department&quot;&gt;&lt;/bean&gt;&lt;!-- 创建员工对象，并注入属性 - 外部部门对象的属性没有赋值，这里通过对象.属性进行赋值 --&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.Key.spring.bean.Employee&quot;&gt; &lt;property name=&quot;empName&quot; value=&quot;孙尚香&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;property name=&quot;empDept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; &lt;property name=&quot;empDept.deptName&quot; value=&quot;销售部&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 2.2.5 自动装配 PS：一般使用注解方式实现自动装配，不使用xml 文件；而且自动装配适用于自定义对象类型的属性 💬概述：只需声明属性的名称或者属性的类型即可完成属性的注入，不需要使用&lt;property&gt;标签手动给各个属性赋值 🔑用法：在&lt;bean&gt;标签中添加属性——autowire，属性值有两种 byName：表示根据Bean 的属性名来赋值，自定义的对象创建的&lt;bean&gt;标签中的id值必须与对象类型的属性名保持一致 byType：表示根据Bean 的属性类型来赋值，属性对应的对象创建在同一个xml 文件中只能出现一次，即同一个xml 文件不能创建与属性对应对象的类型一样的对象 💡当autowire的值为byType 时，spring 会根据属性的类型找到对应的对象（根据&lt;bean&gt;标签中的class属性值），然后将该对象赋值给对应属性，如果同一个xml 文件中出现多个类型一样的对象，spring 就不知道哪一个才是需要赋值的，会报错 2.3 FactoryBean💬概述：spring 中有两种类型的Bean，一种是普通的Bean，一种是工厂Bean——Factory 🔑普通Bean和工厂Bean的区别 普通Bean：在配置文件中定义的bean 类型和返回类型是一样的 工厂Bean：在配置文件中定义的bean 类型和返回类型可以不一样 🔑FactoryBean的实现 创建一个类，实现FactoryBean&lt;T&gt; 接口，作为自定义的工厂对象MyBean 在spring配置文件中创建自定义的工厂对象1&lt;bean id=&quot;myBean&quot; class=&quot;com.Key.spring.bean.MyBean&quot;&gt;&lt;/bean&gt; 在自定义的工厂类中实现接口的 getObject()方法，方法中定义实际返回的bean 类型（泛型 T）1234567public class MyBean implements FactoryBean&lt;User&gt; { @Override public User getObject() throws Exception { // 创建User对象并返回 return new User(&quot;曹操&quot;, 43); }} 2.4 注入外部属性 引入概念——Druid数据库连接池属性信息 数据库驱动类：prop.driverClass=com.mysql.jdbc.Driver（MySQL 5之后是 com.mysql.cj.jdbc.Driver） 数据库地址：prop.url=jdbc:mysql://localhost:3306/xxx 数据库用户名：prop.username=root 数据库用户密码：prop.password=xxx 💬概述：一般用于配置数据库连接的属性信息，需要注入的文件一般命名为 jdbc.properties 🔑使用步骤 创建 jdbc.properties 文件，文件中输入对应的数据库连接信息（druid 的需要的数据库连接信息） 在spring 配置文件中引入context 名称空间（创建方法略，可参考util 名称空间的创建） 在spring 配置文件中使用context 名称空间中的 &lt;context:property-placehoder&gt; 标签将外部属性文件 jdbc.properties 引入1&lt;context:property-placehoder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;context:property-placehoder&gt;标签的属性——location：外部属性文件的位置，如果文件在src目录下，可直接写为 classpath:jdbc.properties 在&lt;bean&gt;标签中使用&lt;property&gt;标签注入外部属性，使用方法与注入其他普通类型属性一样，但 value 的值用表达式代替，表达式为——${属性文件中属性名}（EL表达式？）123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DriverDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${prop.driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;${prop.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; ref=&quot;${prop.username}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${prop.password}&quot;&gt;&lt;/property&gt;&lt;/bean&gt; PS：&lt;property&gt;标签中的name属性值都是DriverDataSource 类中的属性，所以是固定的，不是自定义的","link":"/posts/202212082e3919ae67e6"}],"tags":[{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"IOC","slug":"IOC","link":"/tags/IOC/"},{"name":"xml","slug":"xml","link":"/tags/xml/"}],"categories":[{"name":"后端","slug":"后端","link":"/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Spring学习笔记","slug":"后端/Spring学习笔记","link":"/categories/%E5%90%8E%E7%AB%AF/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"pages":[]}